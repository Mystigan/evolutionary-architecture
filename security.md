## Security

We can set the user and role for this to log the credentials of the user that accessess it.

```
$ echo -n app:user:role | md5
$ echo -n "simple text" | shasum -a 256
```


## Expiring JWT Token

Set a `version` in the `jwt` token, and set the equivalent `version` in the server that signs the token. If we ever need to kick all the users out of the server, then we just need to change the version.

## Should I tie a JWT token to a specific device (detect by user-agent)

No. https://stackoverflow.com/questions/38992239/json-web-token-make-it-client-specific

## Blacklisting JWT

It's not possible to implement actual logout with JWT. From the client side, we can simply remove the JWT token from the localstorage, but cannot prevent user from keeping a copy of it. To ensure that tokens that have been removed cannot be reused, we need to blacklist them.

One way is to store the blacklisted JWT token in Redis, and set the expiry in Redis by computing the time remaining for the token to expire. But this means for every calls that needs the authorization, they need to call Redis to check if the token is still valid or not.

## Algorithm for Blacklisting JWT


Blacklisting token by storing the jwt token not only takes a lot of space, this would probably not work if the user login from multiple devices, since we will only logout from one device, there's no way to know the tokens that the user logged in with. One solution could be to store the jwt token in the database when they are created, but this defeats the purpose of the jwt token (suppose to be stateless). 

A better solution would be to take into consideration what is stored in the jwt token, mainly the `issued_at` and `subject` (user id). Since all the tokens generated will have that attributes, it could be potentially used to invalidate multiple tokens. Consider the following scenario:

User is logged in two devices:
- mobile, issued 3 days ago
- desktop, issued yesterday

The JWT token is set to expire in 7 days (example only, it should be long living). When the user logout, we want to ensure those tokens can no longer be used. This is the algorithm:

- When the user logout, store the `logout_at` in the db. Why not the `last_login_at`? Because if we attempt to use the last login date to compare against the jwt token's `issued_at` date, it will not work when the user login multiple times in different devices. Every login will override the previous last login at date. The `logout_at` date however is one time only, we can always use it to compare it against all the JWT's `issued_at` date. If the date is less than the `logout_at` date, then it is deemed invalid. This will invalidate all the tokens stored on the client side when they make a requests against any resource. 
- Store the same `logout_at` date together with the `user_id` in redis. Set the key to expire with the current `logout_at` + `jwt expire duration`. When the entry expire, we no longer need to check if there are blacklisted tokens (tokens that has not expired, but we define them as expired since the issued date is less than the logout date), since by now all the other token would have expired (original jwt expiry date).
- Now, whenever the user make a request with an old/new jwt token, get the user id. If the redis has the user id available, go to the next step, else just validate as usual.
- The user id is available, get the last `logout_at` date and compare against the `issued_at` date. If it is less, it means the token has been blacklisted. Any new token will pass, since the issued at date is always greater than the last logout date.
- We could just store the data in memory, but it will only work on a single instance, it will not scale for distributed system. Also, on every restart, we need to find users with the `logout_at` + jwt expire duration less than now, and set it in memory. The same goes if the redis server restarts.

With that, we have accomplish four things:
- minimize storage for redis (we only store the user_id and last logout at, and set it to expire from the last logout at + jwt expire duration, instead of storing all the jwts). The entry in redis will also be persisted with max last logout at and the jwt duration). Also, we are only storing one entry versus N JWT tokens generated by the client.
- minimize lookup. We still need to make a lookup to redis on every call, but the logic is only performed (comparing the issued at and last logout at) when the entry exists. It should be faster than performing a db lookup, and it works on multiple services.
- customize message. If the entry exists in redis, and the token is indeed issued before the last logout, we can return a message indicating that the session expired. This would have differentiate it from the invalid jwt token/jwt expired token.

Optimization. We previously set the expired at for the redis entry to be equal the last login at + jwt duration. If you notice, the duration will actually be very short. We would still have to check the token blacklist status for the lifetime of the jwt token. One way to optimized it is to set the last login at date too in the database. It will be updated with every login and will always hold the latest login at date. When we logout the user, create the entry at redis with the last login at, last logout at, user id and set it to expire with the last login at + jwt duration. If the last login at is 4 days, and the jwt duration is 1 week, then the blacklisted entry will only be valid for the remaining 3 days.

## Custom Bearer

How to implement custom bearer

## Basic Authentication 

For ops login.

## Passwords in environment variable

A common mistake is to store plaintext user credentials in the environment variables. We need to distinguish the types of environment variables. It can usually be categorized as `config` or `secret`.

To pass in the credentials through environment variable, hash the `username:password` using SHA256 (or similar hashing that are strong enough). To compare, hash the input `username:password` credentials with those set in the environment variable.


## Encryption

What possible encryption methods are available...

## Replay attack

- timestamp event/requests
- Events without timestamp is invalid
- If the event is out of time(less than 5 minutes/validity period ago, or from the future), it is invalid
- If the action to be taken is only valid for a certain period, set a due date. Action must be carried out within that period
- Set a date on the entity to be updated, for the next change, check if the ts is greater than the previous timestamp, if yes, only update it

## Performance and security as a feature

## Business Login in JWT

JWT should not contain business logic - if the token holds claims that are dynamic, any change to the data requires the old token to be invalidated/blacklisted, and the client has to fetch a new token with the new claims.

JWT Token is best used for `authentication` (who the caller is), even when it can perform `authorization` (what the caller can do) through claims.

## Setting Roles in JWT

JWT token is like a passport - it represents the identity of the user at the time the token is generated, until it expired. Thus, we carry along an assumption that the claims set in the JWT are static and should not change frequently. Roles however can be dynamic. Changing the roles on the server side will still leave the existing JWT token with the old roles.

This can have some serious security consideration, imagine giving an admin access to the token. Even when the token is short-lived, the amount of harm that can be done is immeasuarable. Some possible solution (and problems they introduce):

- maintaining a separate blacklist table, which now makes the application stateful. Also, the blacklist table needs to be stored in a distributed cache to avoid load-balancing issue or role-checking on different application for the same user.
- check the db everytime a requests is send to validate the role (either an independent call, or in the statement query).


## Fuzzy testing (?) with strings

https://github.com/minimaxir/big-list-of-naughty-strings

## Anomaly Detection for requests

In order to accomplish this, we need to detect the usage pattern for each users on the different endpoints. Endpoints such as login will normally be rarely called, hence having a increase request over a short time frame can be suspicious.

- how to detect low requests (below the rate limit) abuse?
- how to detect scraping (if they call it at fixed interval or non-fixed interval)
- how to perform time-series anomaly detection?

## Fraud detection

This may be different than anomaly detection, that it detects the attempts of creating fake resources (accounts, orders) and testing the waters.

## Abuse and DDOS

Abuse and DDOS can be prevented by adding rate-limit to the system, and blacklisting the IP address that exceeded the rate limit frequently. There are active and passive systems that detects the abuse.

- active. State is hold in application. The ip is immediately added to blacklist once the threshold is exceeded, and the user is banned.
- passive. Through log analysis. The request logs are sent to a system to be analysed, and the response is then feed back to a distributed storage (redis etc) and refreshed by the application (or load balancers), which then blacklists the ip.

## Login Jail Gate

https://github.com/alextanhongpin/js-learn/blob/master/counter.md

There are several confusion regarding throttling and rate limiting.

- Throttling is meant to control the usage at a defined time window, e.g. User can only make 100 requests per day.
- Rate limit defines the rate at which an API can be consumed, e.g. User can only make 1 request per second, that is 86,4000 requests per day. But if we apply the throttle, then the user can only call up to 100 requests per day.

## STRIDE


- Spoofing: Authenticity. Using another user credentials without their knowledge. 
- Tampering: Integrity. Tampering of data such as overriding important data or deleting it.
- Repudiation: Non-repudiability. Attackers hide the actions that they have performed, for instance by erasing them from the logs.
- Information disclosure: Confidentiality. Data breaches.
- Denial of Service: Availablity. Prevent regular users from accessing the system, through DDOS etc.
- Elevation of Privilege: Authorization. Attackers attempt to gain higher privileges.

https://en.wikipedia.org/wiki/STRIDE_(security)
https://www.futurelearn.com/courses/cyber-security/0/steps/19631


## References
- https://stackoverflow.com/questions/47224931/is-setting-roles-in-jwt-a-best-practice
- https://assertible.com/blog/api-security-testing-tips-to-prevent-getting-pwned#test-for-authentication-on-all-endpoints
- https://github.com/shieldfy/API-Security-Checklist

For Throttling and Rate Limiting
- https://helpx.adobe.com/coldfusion/api-manager/throttling-and-rate-limiting.html
- https://security.stackexchange.com/questions/74211/what-is-the-difference-between-login-throttling-and-temporary-account-lockout
- http://timoh6.github.io/2015/05/07/Rate-limiting-web-application-login-attempts.html
